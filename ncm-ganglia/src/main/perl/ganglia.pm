# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}

package NCM::Component::ganglia;

use strict;
use warnings;

use base qw(NCM::Component);

use LC::Exception;
use LC::Find;
use LC::File qw(copy makedir);

use EDG::WP4::CCM::Element;
use CAF::FileWriter;
use CAF::FileEditor;
use CAF::Process;
use File::Basename;
use File::Path;

use Readonly;
Readonly::Scalar my $PATH => '/software/components/ganglia';

our $EC=LC::Exception::Context->new->will_store_all;

my $header = '####
#
# This file was generated by ncm-ganglia.
# Please, do not edit it yourself. All your change
# will be remove on next quattor update.
#
';

# Restart the process.
sub restartDaemon {
    my ($self,$daemon) = @_;
    if ( $daemon eq 'gmetad' ) {
      CAF::Process->new([qw(service gmetad restart)], log => $self)->run();
    }
    if ( $daemon eq 'gmond' ) {
      CAF::Process->new([qw(service gmond restart)], log => $self)->run();
    }
    return;
}

sub Configure {
    my ($self, $config) = @_;

    # Get full tree of configuration information for component.
    my $t = $config->getElement($PATH)->getTree();
    my $daemon_file     = '';
    my $client_file     = '';
    my $daemon_contents = '';
    my $client_contents = '';

    # Create the configuration file.
    if ( exists $t->{daemon} ) {
	$daemon_contents = configureDaemon($t->{daemon});
	$daemon_file     = $t->{daemon}->{config_file};
    }

   $client_contents =  configureClient($t->{client});
   $client_file     = $t->{client}->{config_file};
   
   if ( $daemon_file ne '' ) {
	my $daemon = LC::Check::file(
		"$daemon_file",
		contents => $header.$daemon_contents,
		mode => 0644
	);
        if ( $daemon < 0 ) {
	  $self->error("Error creating $daemon_file");
	}
	$self->restartDaemon('gmetad');
   }

   my $client = LC::Check::file(
	"$client_file",
	contents => $header.$client_contents,
	mode => 0644
   );
   if ( $client < 0 ) {
	$self->error("Error creating $client_file");
   }
   $self->restartDaemon('gmond');
    # Restart the daemon if necessary.

}

sub configureDaemon {
  my ($args)     = @_;
  my $contents = '';

  my $gridname       = $args->{gridname};
  my $case_sensitive = $args->{case_sensitive_hostnames};
  my $data_sources   = $args->{data_source};

  while ((my $k,my $v) = each(%{$data_sources}) ) {
	$contents = $contents.'data_source "'.$k.'" '.$v."\n";
  }

  $contents = $contents.'gridname "'.$gridname.'"'."\n";
  $contents = $contents.'case_sensitive_hostnames '.$case_sensitive."\n";

  return $contents;
};

sub configureClient {
 my ($args) = @_;
 my $contents = '';

 my $globals = $args->{globals};

 my $globals_daemonize              = boolean_to_yes_no($globals->{daemonize});
 my $globals_setuid                 = boolean_to_yes_no($globals->{setuid});
 my $globals_user                   = $globals->{user};
 my $globals_debug_level            = $globals->{debug_level};
 my $globals_max_udp_msg_len        = $globals->{max_udp_msg_len};
 my $globals_mute                   = boolean_to_yes_no($globals->{mute});
 my $globals_deaf                   = boolean_to_yes_no($globals->{deaf});
# my $globals_allow_extra_data       = boolean_to_yes_no($globals->{allow_extra_data});
 my $globals_host_dmax              = $globals->{host_dmax};
 my $globals_cleanup_threshold      = $globals->{cleanup_threshold};
 my $globals_send_metadata_interval = $globals->{send_metadata_interval};
 my $globals_gexec                  = boolean_to_yes_no($globals->{gexec});

 my $cluster = $args->{cluster};

 my $cluster_name    = $cluster->{name};
 my $cluster_owner   = $cluster->{owner};
 my $cluster_latlong = $cluster->{latlong};
 my $cluster_url     = $cluster->{url};

 my $host = $args->{host};

 my $host_location = $host->{location};

 my $udp_send_channel = $args->{udp_send_channel};

 my $udp_send_channel_host = $udp_send_channel->{host};
 my $udp_send_channel_port = $udp_send_channel->{port};
 my $udp_send_channel_ttl  = $udp_send_channel->{ttl};

 my $udp_recv_channel = $args->{udp_recv_channel};

 my $udp_recv_channel_port = $udp_recv_channel->{port};

 my $tcp_accept_channel = $args->{tcp_accept_channel};

 my $tcp_accept_channel_port = $tcp_accept_channel->{port};

 my $collection_groups = $args->{collection_groups};

 #
 # Globals Configuration section
 #
 $contents .= "globals {\n";
 $contents .= " daemonize = ".$globals_daemonize."\n";
 $contents .= " setuid = ".$globals_setuid."\n";
 $contents .= " user = ".$globals_user."\n";
 $contents .= " debug_level = ".$globals_debug_level."\n";
 $contents .= " max_udp_msg_len = ".$globals_max_udp_msg_len."\n";
 $contents .= " mute = ".$globals_mute."\n";
 $contents .= " deaf = ".$globals_deaf."\n";
 if ( exists $globals->{allow_extra_data}) {
  $contents .= " allow_extra_data = ".boolean_to_yes_no($globals->{allow_extra_data})."\n";
 }
 $contents .= " host_dmax = ".$globals_host_dmax."\n";
 $contents .= " cleanup_threshold = ".$globals_cleanup_threshold."\n";
 if ( exists $globals->{send_metadata_interval}) {
  $contents .= " send_metadata_interval = ".$globals_send_metadata_interval."\n";
 }
 $contents .= " gexec = ".$globals_gexec."\n";
 if ( exists $globals->{module_dir} ) {
  $contents .= " module_dir = ".$globals->{module_dir}."\n";
 }
 $contents .= "}\n\n";

 #
 # Cluster Configuration section
 #
 $contents .= "cluster {\n";
 $contents .= " name = \"".$cluster_name."\"\n";
 $contents .= " owner = \"".$cluster_owner."\"\n";
 $contents .= " latlong = \"".$cluster_latlong."\"\n";
 $contents .= " url = \"".$cluster_url."\"\n",
 $contents .= "}\n\n";

 #
 # Host Configuration section
 #
 $contents .= "host {\n";
 $contents .= " location = \"".$host_location."\"\n";
 $contents .= "}\n\n";

 #
 # udp_send_channel Configuration section
 #
 $contents .= "udp_send_channel {\n";
 $contents .= " host = ".$udp_send_channel_host."\n";
 $contents .= " port = ".$udp_send_channel_port."\n";
 $contents .= " ttl = ".$udp_send_channel_ttl."\n";
 if ( exists $udp_send_channel->{mcast_join} ) {
  $contents .= " mcast_join = ".$udp_send_channel->{mcast_join}."\n";
 }
 if ( exists $udp_send_channel->{mcast_if} ) {
  $contents .= " mcast_join = ".$udp_send_channel->{mcast_if}."\n";
 }
 $contents .= "}\n\n";

 #
 # udp_recv_channel Configuration section
 #
 $contents .= "udp_recv_channel {\n";
 $contents .= " port = ".$udp_recv_channel_port."\n";
 if ( exists ($udp_recv_channel->{mcast_join}) ) {
  $contents .= " mcast_join = ".$udp_recv_channel->{mcast_join}."\n";
 }
 if ( exists ($udp_recv_channel->{bind}) ) {
  $contents .= " bind = ".$udp_recv_channel->{bind}."\n";
 }
 if ( exists ($udp_recv_channel->{mcast_if}) ) {
  $contents .= " mcast_if = ".$udp_recv_channel->{mcast_if}."\n";
 }
 if ( exists ($udp_recv_channel->{family}) ) {
  $contents .= " family = ".$udp_recv_channel->{family}."\n";
 }
 if ( exists ($udp_recv_channel->{acl}) ) {
  my $acl = $udp_recv_channel->{acl};
  $contents .= "  acl {\n";
  $contents .= "   default = \"".$acl->{default}."\"\n";
  foreach my $i (@{$acl->{access}}) {
   $contents .= "   access {\n";
   $contents .= "    ip = ".$i->{ip}."\n";
   $contents .= "    mask = ".$i->{mask}."\n";
   $contents .= "    action = \"".$i->{action}."\"\n";
   $contents .= "   }\n"; 
  }
  $contents .= "  }\n";
 } 
 $contents .= "}\n\n";

 #
 # tcp_accept_channel Configuration section
 #
 $contents .= "tcp_accept_channel {\n";
 $contents .= " port = ".$tcp_accept_channel_port."\n";
 if ( exists ($tcp_accept_channel->{bind}) ) {
  $contents .= " bind = ".$tcp_accept_channel->{bind}."\n";
 }
 if ( exists ($tcp_accept_channel->{interface}) ) {
  $contents .= " interface = ".$tcp_accept_channel->{interface}."\n";
 }
 if ( exists ($tcp_accept_channel->{family}) ) {
  $contents .= " family = ".$tcp_accept_channel->{family}."\n";
 }
 if ( exists ($tcp_accept_channel->{timeout}) ) {
  $contents .= " timeout = ".$tcp_accept_channel->{timeout}."\n";
 }
 if ( exists ($tcp_accept_channel->{acl}) ) {
  my $acl = $tcp_accept_channel->{acl};
  $contents .= "  acl {\n";
  $contents .= "   default = \"".$acl->{default}."\"\n";
  foreach my $i (@{$acl->{access}}) {
   $contents .= "   access {\n";
   $contents .= "    ip = ".$i->{ip}."\n";
   $contents .= "    mask = ".$i->{mask}."\n";
   $contents .= "    action = \"".$i->{action}."\"\n";
   $contents .= "   }\n";
  }
  $contents .= "  }\n";
 }
 $contents .= "}\n\n";

 #
 # Modules Configuration section
 #
 if ( exists($args->{modules}) ) {
  my $modules = $args->{modules};
  $contents .= "modules {\n";
  foreach my $i (@{$modules}) {
   $contents .= "  module {\n";
   $contents .= "   name = \"".$i->{name}."\"\n";
   if ( exists ($i->{path})) {
    $contents .= "   path = \"".$i->{path}."\"\n";
   }
   if ( exists ($i->{enabled})) {
    $contents .= "  enabled = ".boolean_to_yes_no($i->{enabled})."\n";
   }
   if ( exists ($i->{params}) ) {
    $contents .= "  params = \"".$i->{params}."\"\n";
   }
   if ( exists ($i->{param}) ) {
    while ((my $k,my $v) = each(%{$i->{param}}) ) {
     $contents .= "  param ".$k." { \n";
     $contents .= "   value = ".$v."\n";
     $contents .= "  }\n";
    }
   }
   $contents .= "  }\n";
  }
  $contents .= "}\n\n";
 }

 #
 # Includes Configuration section
 #
 if ( exists($args->{includes}) ) {
  my $includes = $args->{includes};
  foreach my $i (@{$includes}) {
   $contents .= "include(\'".$i."\')\n";
  }
  $contents .= "\n";
 }

 #
 # collection_group Configuration section
 #
 foreach my $i (@{$collection_groups}) {
  $contents .= "collection_group {\n";
  if ( exists $i->{collect_once} ) {
   $contents .= " collect_once = ".boolean_to_yes_no($i->{collect_once})."\n";
  }
  if (exists $i->{collect_every}) {
   $contents .= " collect_every = ".$i->{collect_every}."\n";
  }
  if (exists $i->{time_threshold}) {
   $contents .= " time_threshold = ".$i->{time_threshold}."\n";
  }
  foreach my $j (@{$i->{metric}}) {
   $contents .=  " metric {\n";
   $contents .=  "  name = \"".$j->{name}."\"\n";
   if (exists $j->{value_threshold}) {
    $contents .= "  value_threshold = \"".$j->{value_threshold}."\"\n";
   }
   if (exists $j->{title}) {
    $contents .= "  title = \"".$j->{title}."\"\n";
   }
   $contents .=  " }\n";
  }
  $contents .= "}\n\n"; 
 }

 return $contents;
};

#
# Function which convert boolean to string 'yes' or 'no'
#
sub boolean_to_yes_no {
 my ($args) = @_;

 if ($args == 1 ) {
  return 'yes';
 } else {
  return 'no';
 }
}

1; # Required for perl module!
