@BUILD_INFO@
@LEGAL@

package NCM::Component::@COMP@;

use strict;
use warnings;
use NCM::Component;
use EDG::WP4::CCM::Property;
use NCM::Check;
use FileHandle;
use File::Basename;

use CAF::FileWriter;
use CAF::Process;
use LC::File qw (makedir);

use constant PATH => '/software/components/@COMP@';
use constant COMPONENT_NAME => '@COMP@';

our @ISA = qw (NCM::Component);
our $EC = LC::Exception::Context->new->will_store_all;

# Mark what values are not quoted.
our %unquoted = (
    'listen_tls' => 1,
    'listen_tcp' => 1,
    'mdns_adv' => 1,
    'tls_no_verify_certificate' => 1,
    'max_clients' => 1,
    'min_workers' => 1,
    'max_workers' => 1,
    'max_requests' => 1,
    'max_client_requests' => 1,
    'log_level' => 1
);


# If the value isn't listed in unquoted hash, quote it.
sub quoteValue {
    my ($k, $v) = @_;
    return (($unquoted{$k}) ? $v :  '"' . $v . '"');
}

# Write out hash as sequence of key/value pairs.
sub writeKeyValuePairs {
    my ($href) = $_[0];

    if ($href) {
	my %pairs = %{$href};
	my @entries;
	foreach my $k (sort keys %pairs) {
	    my $v = quoteValue($k, $pairs{$k});
	    push @entries, $k . '=' . $v;
	}
	
	$_[1] .= join("\n", @entries) . "\n";
    }
}

sub listToString {
    my (@entries) = @{$_[0]};
}

# Write out the authorization parameters.
sub writeAuthz {
    my ($href) = $_[0];

    if ($href) {
	
	my (%pairs) = %{$href};

	my $k = 'tls_no_verify_certificate';
	my $v = $pairs{$k};
	$_[1] .= "$k=" . quoteValue($k, $v) . "\n" if defined($v);

	$k = 'tls_allowed_dn_list';
	my $aref = $pairs{$k};
	if ($aref) {
	    my @entries = @{$aref};
	    my $s = join(' ', @entries);
	    $_[1] .= "$k=\"" . $s . "\"\n";
	}

	$k = 'sasl_allowed_username_list';
	$aref = $pairs{$k};
	if ($aref) {
	    my @entries = @{$aref};
	    my $s = join(' ', @entries);
	    $_[1] .= "$k=\"" . $s . "\"\n";
	}
    }

}

# Write out the logging parameters.
sub writeLogging {
    my ($href) = $_[0];

    if ($href) {
	my (%pairs) = %{$href};

	my $k = 'log_level';
	my $v = $pairs{$k};
	$_[1] .= "$k=" . quoteValue($k, $v) . "\n" if defined($v);
	
	$k = 'log_filter';
	my $aref = $pairs{$k};
	if ($aref) {
	    my @entries = @{$aref};
	    my $s = join(' ', @entries);
	    $_[1] .= "$k=\"" . $s . "\"\n";
	}

	$k = 'log_outputs';
	$aref = $pairs{$k};
	if ($aref) {
	    my @entries = @{$aref};
	    my $s = join(' ', @entries);
	    $_[1] .= "$k=\"" . $s . "\"\n";
	}
    }
}

# Restart the process.
sub restartDaemon {
    my ($self) = @_;
    CAF::Process->new([qw(/etc/init.d/libvirtd restart)], log => $self)->run();
}

sub Configure {
    my ($self, $config) = @_;

    my $t = $config->getElement(PATH)->getTree;

    # First retrieve the configuration file location.
    my $libvirtd_config = $t->{'libvirtd_config'};
    my $config_dir = basename($libvirtd_config);
    if (!makedir($config_dir, 0755)) {
        $self->error("Failed to create configuration directory: $config_dir");
        return;
    }

    # Accumulate the configuration in a string.
    my $contents = 
        "#\n". 
        '# autogenerated by ' . 
        COMPONENT_NAME .
        " configuration module\n" . 
        "#\n";

    my $href;

    $contents .= "\n# networking parameters\n\n";
    writeKeyValuePairs($t->{'network'}, $contents);

    $contents .= "\n# unix socket parameters\n\n";
    writeKeyValuePairs($t->{'socket'}, $contents);

    $contents .= "\n# authentication parameters\n\n";
    writeKeyValuePairs($t->{'authn'}, $contents);

    $contents .= "\n# TLS parameters\n\n";
    writeKeyValuePairs($t->{'tls'}, $contents);

    $contents .= "\n# authorization parameters\n\n";
    writeAuthz($t->{'authz'}, $contents);

    $contents .= "\n# processing control parameters\n\n";
    writeKeyValuePairs($t->{'processing'}, $contents);

    $contents .= "\n# logging parameters\n\n";
    writeLogging($t->{'logging'}, $contents);

    # Write out the contents of the configuration file.
    my $fh = CAF::FileWriter->open("$libvirtd_config");
    print $fh $contents;
    my $config_changed = $fh->close();

    # If configuration has changed restart the service.
    restartDaemon($self) if ($config_changed);

    return 1;
}

1;
